)]}'
{"version":3,"sources":["iron:location/lib/utils.js","iron:location/lib/state.js","iron:location/lib/location.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mB;AACA,+B;;AAEA,G;AACA,S;AACA,qD;AACA,E;AACA,U;AACA,+D;AACA,G;AACA,iC;AACA,6B;AACA,uD;AACA,4B;AACA,gC;AACA,4B;;AAEA,qD;AACA,uC;AACA,uD;AACA,2C;AACA,8B;AACA,c;AACA,G;;AAEA,2D;AACA,2B;AACA,wC;AACA,oB;AACA,sB;AACA,G;;AAEA,U;AACA,S;AACA,S;AACA,U;AACA,a;AACA,E;;AAEA,G;AACA,+E;AACA,sC;AACA,E;AACA,S;AACA,+D;AACA,G;AACA,U;AACA,qD;AACA,G;AACA,mC;AACA,6B;AACA,6D;AACA,4B;AACA,2B;AACA,W;;AAEA,8E;AACA,2E;AACA,kD;AACA,oD;AACA,8C;AACA,U;AACA,c;AACA,G;;AAEA,U;AACA,S;AACA,a;AACA,yC;AACA,Q;AACA,a;AACA,E;;AAEA,G;AACA,yE;AACA,mC;AACA,G;AACA,mC;AACA,kC;AACA,gC;AACA,E;AACA,gE;AACA,mB;AACA,wD;AACA,G;;AAEA,U;AACA,Q;AACA,gC;AACA,4B;AACA,a;AACA,E;;;;;;;;;;;;;;;;;;;AC3FA,mB;;AAEA,iC;AACA,2D;AACA,E;;AAEA,yD;AACA,2C;AACA,a;AACA,iB;;AAEA,gC;AACA,iB;;AAEA,wC;AACA,mC;AACA,+B;AACA,8D;AACA,gB;;AAEA,e;AACA,E;;AAEA,2C;AACA,6B;AACA,E;;AAEA,+C;AACA,2B;AACA,E;;;;;;;;;;;;;;;;;;;AC7BA,+E;AACA,a;AACA,+E;AACA,mB;;AAEA,+E;AACA,a;AACA,+E;AACA,mB;AACA,8B;AACA,sC;;AAEA,yB;AACA,6C;AACA,E;;AAEA,yB;AACA,6C;AACA,E;;AAEA,gC;AACA,6B;AACA,C;;AAEA,wC;AACA,wF;AACA,C;;AAEA,sC;AACA,2G;AACA,E;;AAEA,oC;AACA,yC;AACA,E;;AAEA,yC;AACA,uC;AACA,mB;AACA,K;AACA,C;;AAEA,4B;AACA,gC;AACA,iD;;AAEA,+B;AACA,oB;AACA,kB;;AAEA,4D;AACA,gB;AACA,G;;AAEA,kB;AACA,e;AACA,E;;AAEA,4C;AACA,2B;AACA,Y;;AAEA,2B;AACA,8C;AACA,U;AACA,2D;AACA,G;;AAEA,iC;AACA,a;AACA,E;;AAEA,gC;AACA,+B;AACA,wB;AACA,E;;AAEA,G;AACA,e;AACA,G;AACA,kC;AACA,0B;;AAEA,sC;;AAEA,2B;;AAEA,mB;AACA,iC;AACA,6E;AACA,iB;AACA,iC;AACA,iC;AACA,2C;AACA,gB;AACA,4C;AACA,kE;AACA,c;AACA,+D;AACA,S;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,mC;AACA,O;AACA,6B;AACA,uB;AACA,iD;;AAEA,4E;AACA,sC;;AAEA,qC;AACA,iC;AACA,yB;AACA,a;AACA,K;;AAEA,+B;AACA,6C;AACA,a;;AAEA,oC;AACA,kB;AACA,a;;AAEA,iC;AACA,+C;AACA,a;;AAEA,oE;AACA,4C;AACA,uB;;AAEA,8E;AACA,a;AACA,iB;AACA,0E;AACA,c;AACA,uB;AACA,c;AACA,G;AACA,E;;AAEA,+E;AACA,kB;AACA,+E;;AAEA,G;AACA,2E;AACA,+D;AACA,G;AACA,c;;AAEA,G;AACA,mB;AACA,G;AACA,oB;AACA,0B;AACA,qB;AACA,E;;AAEA,G;AACA,sC;AACA,G;AACA,yC;AACA,wC;AACA,E;;AAEA,G;AACA,oC;AACA,G;AACA,4B;AACA,e;AACA,iB;AACA,E;;AAEA,G;AACA,4D;AACA,G;AACA,8B;AACA,sB;AACA,W;;AAEA,uC;;AAEA,2E;AACA,+E;AACA,6D;AACA,6B;AACA,gF;AACA,uB;AACA,oC;AACA,8C;AACA,4B;AACA,K;;AAEA,oB;AACA,yC;AACA,G;AACA,sB;AACA,2B;;AAEA,2B;AACA,kD;AACA,e;AACA,U;AACA,8E;AACA,6D;AACA,iD;AACA,wC;AACA,K;AACA,I;AACA,0D;AACA,+B;AACA,gF;AACA,qE;AACA,+E;AACA,+D;AACA,sC;AACA,mD;AACA,8D;AACA,e;AACA,G;;AAEA,4B;AACA,mE;AACA,qE;;AAEA,kE;AACA,8B;AACA,sF;AACA,K;AACA,E;AACA,yB;AACA,E;;AAEA,G;AACA,oD;AACA,G;AACA,6B;AACA,uB;AACA,W;;AAEA,yC;AACA,2C;AACA,yC;;AAEA,0B;AACA,E;;AAEA,G;AACA,oC;AACA,G;AACA,kC;AACA,sB;AACA,E;;AAEA,G;AACA,mB;AACA,G;AACA,uC;AACA,0B;AACA,E;;AAEA,G;AACA,gE;AACA,E;AACA,qD;AACA,2D;AACA,G;AACA,+B;AACA,uB;AACA,E;;AAEA,G;AACA,uE;AACA,E;AACA,qD;AACA,2D;AACA,G;AACA,qC;AACA,6B;AACA,E;;AAEA,G;AACA,oC;AACA,G;AACA,iB;;AAEA,+E;AACA,iB;AACA,+E;AACA,yB","file":"/packages/iron:location.js","sourcesContent":["var Url = Iron.Url;\nvar HASH_PARAM_NAME='__hash__';\n\n/**\n * Given:\n *   http://host:port/some/pathname/?query=string#bar\n *\n * Return:\n *   http://host:port#!some/pathname/?query=string&__hash__=bar\n */\nurlToHashStyle = function (url) {\n  var parts = Url.parse(url);\n  var hash = parts.hash && parts.hash.replace('#', '');\n  var search = parts.search;\n  var pathname = parts.pathname;\n  var root = parts.rootUrl; \n\n  // do we have another hash value that isn't a path?\n  if (hash && hash.charAt(0) !== '!') {\n    var hashQueryString = HASH_PARAM_NAME + '=' + hash;\n    search = search ? (search + '&') : '?';\n    search += hashQueryString;\n    hash = '';\n  }\n\n  // if we don't already have a path on the hash create one\n  if (! hash && pathname) {\n    hash = '#!' + pathname.substring(1);\n  } else if (hash) {\n    hash = '#' + hash;\n  }\n\n  return [\n    root,\n    hash,\n    search\n  ].join('');\n};\n\n/**\n * Given a url that uses the hash style (see above), return a new url that uses\n * the hash path as a normal pathname.\n *\n * Given:\n *   http://host:port#!some/pathname/?query=string&__hash__=bar\n * \n * Return:\n *   http://host:port/some/pathname/?query=string#bar\n */\nurlFromHashStyle = function (url) {\n  var parts = Url.parse(url);\n  var pathname = parts.hash && parts.hash.replace('#!', '/');\n  var search = parts.search;\n  var root = parts.rootUrl;\n  var hash;\n\n  // see if there's a __hash__=value in the query string in which case put it \n  // back in the normal hash position and delete it from the search string.\n  if (_.has(parts.queryObject, HASH_PARAM_NAME)) {\n    hash = '#' + parts.queryObject[HASH_PARAM_NAME];\n    delete parts.queryObject[HASH_PARAM_NAME];\n  } else {\n    hash = '';\n  }\n\n  return [\n    root,\n    pathname,\n    Url.toQueryString(parts.queryObject),\n    hash\n  ].join('');\n};\n\n/**\n * Fix up a pathname intended for use with a hash path by moving any hash\n * fragments into the query string.\n */\nfixHashPath = function (pathname) {\n  var parts = Url.parse(pathname);\n  var query = parts.queryObject;\n  \n  // if there's a hash in the path move that to the query string\n  if (parts.hash) {\n    query[HASH_PARAM_NAME] = parts.hash.replace('#', '')\n  }\n\n  return [\n    '!',\n    parts.pathname.substring(1),\n    Url.toQueryString(query)\n  ].join('');\n};\n","var Url = Iron.Url;\n\nState = function (url, options) {\n  _.extend(this, Url.parse(url), {options: options || {}});\n};\n\n// XXX: should this compare options (e.g. history.state?)\nState.prototype.equals = function (other) {\n  if (!other)\n    return false;\n\n  if (!(other instanceof State))\n    return false;\n\n  if (other.pathname == this.pathname &&\n     other.search == this.search &&\n     other.hash == this.hash &&\n     other.options.historyState === this.options.historyState)\n    return true;\n\n  return false;\n};\n\nState.prototype.isCancelled = function () {\n  return !!this._isCancelled;\n};\n\nState.prototype.cancelUrlChange = function () {\n  this._isCancelled = true;\n};\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar Url = Iron.Url;\n\n/*****************************************************************************/\n/* Private */\n/*****************************************************************************/\nvar current = null;\nvar dep = new Deps.Dependency;\nvar handlers = {go: [], popState: []};\n\nvar isIE9 = function () {\n  return /MSIE 9/.test(navigator.appVersion);\n};\n\nvar isIE8 = function () {\n  return /MSIE 8/.test(navigator.appVersion);\n};\n\nvar usingAppcache = function() {\n  return !! Package.appcache;\n}\n\nvar replaceStateUndefined = function() {\n  return (typeof history === \"undefined\")  || (typeof history.pushState !== \"function\");\n}\n\nvar shouldUseHashPaths = function () {\n  return Location.options.useHashPaths || isIE8() || isIE9() || usingAppcache() || replaceStateUndefined();\n};\n\nvar isUsingHashPaths = function () {\n  return !!Location.options.useHashPaths;\n};\n\nvar runHandlers = function(name, state) {\n  _.each(handlers[name], function(cb) {\n    cb.call(state);\n  });\n}\n\nvar set = function (state) {\n  if (!(state instanceof State))\n    throw new Error(\"Expected a State instance\");\n\n  if (!state.equals(current)) {\n    current = state;\n    dep.changed();\n\n    // return true to indicate state was set to a new value.\n    return true;\n  }\n\n  // state not set\n  return false;\n};\n\nvar setStateFromEventHandler = function () {\n  var href = location.href;\n  var state;\n\n  if (isUsingHashPaths()) {\n    state = new State(urlFromHashStyle(href));\n  } else {\n    state = new State(href, {historyState: history.state});\n  }\n\n  runHandlers('popState', state);\n  set(state);\n};\n\nvar fireOnClick = function (e) {\n  var handler = onClickHandler;\n  handler && handler(e);\n};\n\n/**\n * Go to a url.\n */\nvar go = function (url, options) {\n  options = options || {};\n\n  var state = new State(url, options);\n\n  runHandlers('go', state);\n\n  if (set(state)) {\n    Deps.afterFlush(function () {\n      // if after we've flushed if nobody has cancelled the state then change\n      // the url.\n      if (!state.isCancelled()) {\n        if (isUsingHashPaths()) {\n          location.hash = fixHashPath(url);\n        } else {\n          if (options.replaceState === true)\n            history.replaceState(options.historyState, null, url);\n          else\n            history.pushState(options.historyState, null, url);\n        }\n      }\n    });\n  }\n};\n\nvar onClickHandler = function (e) {\n  try {\n    var el = e.currentTarget;\n    var href = el.href;\n    var path = el.pathname + el.search + el.hash;\n\n    // ie9 omits the leading slash in pathname - so patch up if it's missing\n    path = path.replace(/(^\\/?)/,\"/\");\n\n    // haven't been cancelled already\n    if (e.isDefaultPrevented()) {\n      e.preventDefault();\n      return;\n    }\n\n    // with no meta key pressed\n    if (e.metaKey || e.ctrlKey || e.shiftKey)\n      return;\n\n    // aren't targeting a new window\n    if (el.target)\n      return;\n\n    // aren't external to the app\n    if (!Url.isSameOrigin(href, location.href))\n      return;\n\n    // note that we _do_ handle links which point to the current URL\n    // and links which only change the hash.\n    e.preventDefault();\n\n    // manage setting the new state and maybe pushing onto the pushState stack\n    go(path);\n  } catch (err) {\n    // make sure we can see any errors that are thrown before going to the\n    // server.\n    e.preventDefault();\n    throw err;\n  }\n};\n\n/*****************************************************************************/\n/* Location API */\n/*****************************************************************************/\n\n/**\n * Main Location object. Reactively respond to url changes. Normalized urls\n * between hash style (ie8/9) and normal style using pushState.\n */\nLocation = {};\n\n/**\n * Default options.\n */\nLocation.options = {\n  linkSelector: 'a[href]',\n  useHashPaths: false\n};\n\n/**\n * Set options on the Location object.\n */\nLocation.configure = function (options) {\n  _.extend(this.options, options || {});\n};\n\n/**\n * Reactively get the current state.\n */\nLocation.get = function () {\n  dep.depend();\n  return current;\n};\n\n/**\n * Set the initial state and start listening for url events.\n */\nLocation.start = function () {\n  if (this._isStarted)\n    return;\n\n  var parts = Url.parse(location.href);\n\n  // if we're using the /#/items/5 style then start off at the root url but\n  // store away the pathname, query and hash into the hash fragment so when the\n  // client gets the response we can render the correct page.\n  if (shouldUseHashPaths()) {\n    // if we have any pathname like /items/5 take a trip to the server to get us\n    // back a root url.\n    if (parts.pathname.length > 1) {\n      var url = urlToHashStyle(location.href);\n      window.location = url;\n    }\n\n    // ok good to go\n    this.configure({useHashPaths: true});\n  }\n  // set initial state\n  var href = location.href;\n\n  if (isUsingHashPaths()) {\n    var state = new State(urlFromHashStyle(href));\n    set(state);\n  } else {\n    // if we started at a URL in the /#!items/5 style then we have picked up a\n    // URL from an non-HTML5 user. Let's redirect to /items/5\n    if (parts.hash.replace('#', '')[0] === '!') {\n      var href = urlFromHashStyle(href);\n    }\n    \n    // store the fact that this is the first route we hit.\n    // this serves two purposes\n    //   1. We can tell when we've reached an unhandled route and need to show a\n    //      404 (rather than bailing out to let the server handle it)\n    //   2. Users can look at the state to tell if the history.back() will stay\n    //      inside the app (this is important for mobile apps).\n    var historyState = {initial: true}\n    history.replaceState(historyState, null, href);\n    var state = new State(href, {historyState: historyState});\n    set(state);\n  }\n\n  // bind the event handlers\n  $(window).on('popstate.iron-location', setStateFromEventHandler);\n  $(window).on('hashchange.iron-location', setStateFromEventHandler);\n\n  // make sure we have a document before binding the click handler\n  Meteor.startup(function () {\n    $(document).on('click.iron-location', Location.options.linkSelector, fireOnClick);\n  });\n  \n  this._isStarted = true;\n};\n\n/**\n * Stop the Location from listening for url changes.\n */\nLocation.stop = function () {\n  if (!this._isStarted)\n    return;\n\n  $(window).on('popstate.iron-location');\n  $(window).on('hashchange.iron-location');\n  $(document).off('click.iron-location');\n\n  this._isStarted = false;\n};\n\n/**\n * Assign a different click handler.\n */\nLocation.onClick = function (fn) {\n  onClickHandler = fn;\n};\n\n/**\n * Go to a new url.\n */\nLocation.go = function (url, options) {\n  return go(url, options);\n};\n\n/**\n * Run the supplied callback whenever we \"go\" to a new location.\n *\n * Argument: cb - function, called with no arguments,\n * `this` is the state that's being set, _may_ be modified.\n */\nLocation.onGo = function (cb) {\n  handlers.go.push(cb);\n};\n\n/**\n * Run the supplied callback whenever we \"popState\" to an old location.\n *\n * Argument: cb - function, called with no arguments,\n * `this` is the state that's being set, _may_ be modified.\n */\nLocation.onPopState = function (cb) {\n  handlers.popState.push(cb);\n};\n\n/**\n * Automatically start Iron.Location\n */\nLocation.start();\n\n/*****************************************************************************/\n/* Namespacing */\n/*****************************************************************************/\nIron.Location = Location;\n"]}