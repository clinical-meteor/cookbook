{"version":3,"sources":["iron:middleware-stack/lib/handler.js","iron:middleware-stack/lib/middleware_stack.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,mB;;AAEA,wC;AACA,2B;AACA,kC;AACA,c;AACA,e;AACA,I;AACA,oE;AACA,0E;AACA,2E;AACA,2E;AACA,gE;AACA,2B;;AAEA,6C;AACA,2B;AACA,G;;AAEA,qD;AACA,+E;AACA,mC;AACA,+B;AACA,iB;AACA,oC;AACA,G;;AAEA,0B;;AAEA,yB;AACA,6B;AACA,0E;;AAEA,+D;AACA,yE;AACA,kB;AACA,yC;;AAEA,0E;AACA,kC;AACA,iB;AACA,wB;;AAEA,iB;AACA,mB;AACA,6B;AACA,8D;AACA,qB;AACA,yB;AACA,wB;AACA,oD;AACA,mD;;AAEA,8E;AACA,kB;AACA,+D;AACA,8B;;AAEA,yD;AACA,sB;;AAEA,mB;AACA,4C;;AAEA,uB;AACA,sC;AACA,gF;AACA,qB;AACA,0B;;AAEA,qC;AACA,wF;;AAEA,yC;AACA,M;AACA,gC;AACA,qC;AACA,qB;AACA,G;AACA,E;;AAEA,G;AACA,sE;AACA,8E;AACA,wD;AACA,G;AACA,mD;AACA,0B;;AAEA,+C;AACA,2B;AACA,wB;;AAEA,oC;AACA,gE;;AAEA,oB;AACA,6C;;AAEA,mD;AACA,E;;AAEA,4C;AACA,uC;AACA,E;;AAEA,wD;AACA,mD;AACA,E;;AAEA,G;AACA,gC;AACA,mE;AACA,G;AACA,uC;AACA,gE;AACA,6C;AACA,yB;AACA,e;AACA,E;;;;;;;;;;;;;;;;;;;ACvHA,mB;AACA,+B;AACA,2C;;AAEA,G;AACA,6E;AACA,E;AACA,8E;AACA,uE;AACA,8E;AACA,gF;AACA,8E;AACA,sB;AACA,E;AACA,2E;AACA,+E;AACA,0E;AACA,E;AACA,G;AACA,+B;AACA,mB;AACA,kB;AACA,E;;AAEA,kE;AACA,+C;AACA,0B;;AAEA,a;AACA,mC;AACA,0E;AACA,K;AACA,gC;AACA,G;;AAEA,iB;AACA,E;;AAEA,wD;AACA,2B;AACA,E;;AAEA,G;AACA,qC;AACA,G;AACA,+D;AACA,gD;AACA,4B;AACA,gB;AACA,iB;AACA,E;;AAEA,2E;AACA,kB;AACA,kC;AACA,mB;;AAEA,8C;AACA,yB;;AAEA,qC;AACA,yC;AACA,a;AACA,6C;AACA,oC;AACA,kC;AACA,2D;AACA,Q;AACA,oF;AACA,K;;AAEA,c;AACA,E;;AAEA,G;AACA,qD;AACA,E;AACA,4E;AACA,+E;AACA,8E;AACA,gB;AACA,G;AACA,0E;AACA,gD;AACA,wC;AACA,mC;AACA,c;AACA,E;;AAEA,G;AACA,iD;AACA,G;AACA,6E;AACA,oB;AACA,Y;;AAEA,2C;AACA,sF;;AAEA,gD;AACA,0C;AACA,c;AACA,E;;AAEA,G;AACA,gD;AACA,E;AACA,G;AACA,4E;AACA,c;AACA,Y;;AAEA,qC;AACA,sF;;AAEA,0C;AACA,8C;AACA,c;AACA,E;;AAEA,G;AACA,yE;AACA,4E;AACA,yD;AACA,G;AACA,qE;AACA,gC;AACA,sC;AACA,iD;AACA,sG;AACA,gE;AACA,kC;AACA,a;AACA,E;;AAEA,G;AACA,2E;AACA,oC;AACA,G;AACA,6E;AACA,kB;AACA,wB;;AAEA,kD;AACA,iE;;AAEA,kC;;AAEA,uC;AACA,wC;AACA,4C;;AAEA,8D;AACA,mD;AACA,2E;AACA,2C;;AAEA,kD;AACA,4B;AACA,K;;AAEA,8D;AACA,0C;AACA,K;;AAEA,8D;AACA,0C;AACA,K;;AAEA,iC;AACA,e;AACA,W;AACA,oC;AACA,qB;AACA,2E;AACA,gF;AACA,0C;AACA,yB;;AAEA,0B;AACA,kB;AACA,O;AACA,K;AACA,I;;AAEA,gB;;AAEA,8D;AACA,uC;;AAEA,oB;AACA,4D;;AAEA,iB;AACA,4C;;AAEA,sD;AACA,uB;;AAEA,6E;AACA,0E;AACA,mE;AACA,sD;;AAEA,6E;AACA,gF;AACA,0E;AACA,uC;AACA,4B;AACA,oD;;AAEA,uE;AACA,gC;AACA,uB;;AAEA,uE;AACA,2B;AACA,yD;AACA,mE;AACA,uC;;AAEA,iC;AACA,2E;AACA,qD;AACA,wB;;AAEA,wB;AACA,kE;AACA,4D;AACA,qC;AACA,iD;AACA,K;;AAEA,S;AACA,Q;AACA,+E;AACA,Q;AACA,qC;AACA,0C;AACA,0B;AACA,uC;AACA,gC;AACA,iC;;AAEA,uC;AACA,6B;AACA,iE;;AAEA,kC;AACA,4B;AACA,4D;;AAEA,mE;AACA,gF;AACA,Y;AACA,uB;AACA,mB;AACA,oB;AACA,wD;AACA,kB;AACA,U;AACA,+D;AACA,kB;AACA,e;AACA,0D;AACA,+D;AACA,sE;AACA,6E;AACA,mD;AACA,8B;AACA,0B;AACA,K;AACA,K;;AAEA,S;;AAEA,sB;AACA,iB;AACA,E;;AAEA,kB;AACA,uC","file":"/packages/iron:middleware-stack.js","sourcesContent":["var Url = Iron.Url;\n\nHandler = function (path, fn, options) {\n  if (_.isFunction(path)) {\n    options = options || fn || {};\n    fn = path;\n    path = '/';\n    \n    // probably need a better approach here to differentiate between\n    // Router.use(function () {}) and Router.use(MyAdminApp). In the first\n    // case we don't want to count it as a viable server handler when we're\n    // on the client and need to decide whether to go to the server. in the\n    // latter case, we DO want to go to the server, potentially.\n    this.middleware = true;\n\n    if (typeof options.mount === 'undefined')\n      options.mount = true;\n  }\n\n  // if fn is a function then typeof fn => 'function'\n  // but note we can't use _.isObject here because that will return true if the\n  // fn is a function OR an object.\n  if (typeof fn === 'object') {\n    options = fn;\n    fn = options.action || 'action';\n  }\n\n  options = options || {};\n\n  this.options = options;\n  this.mount = options.mount;\n  this.method = (options.method && options.method.toLowerCase()) || false;\n\n  // should the handler be on the 'client', 'server' or 'both'?\n  // XXX can't we default this to undefined in which case it's run in all\n  // environments?\n  this.where = options.where || 'client';\n\n  // if we're mounting at path '/foo' then this handler should also handle\n  // '/foo/bar' and '/foo/bar/baz'\n  if (this.mount)\n    options.end = false;\n\n  // set the name\n  if (options.name)\n    this.name = options.name;\n  else if (typeof path === 'string' && path.charAt(0) !== '/')\n    this.name = path;\n  else if (fn && fn.name)\n    this.name = fn.name;\n  else if (typeof path === 'string' && path !== '/')\n    this.name = path.split('/').slice(1).join('.');\n\n  // if the path is explicitly set on the options (e.g. legacy router support)\n  // then use that\n  // otherwise use the path argument which could also be a name\n  path = options.path || path;\n\n  if (typeof path === 'string' && path.charAt(0) !== '/')\n    path = '/' + path;\n\n  this.path = path;\n  this.compiledUrl = new Url(path, options);\n\n  if (_.isString(fn)) {\n    this.handle = function handle () {\n      // try to find a method on the current thisArg which might be a Controller\n      // for example.\n      var func = this[fn];\n\n      if (typeof func !== 'function')\n        throw new Error(\"No method named \" + JSON.stringify(fn) + \" found on handler.\");\n\n      return func.apply(this, arguments);\n    };\n  } else if (_.isFunction(fn)) {\n    // or just a regular old function\n    this.handle = fn;\n  }\n};\n\n/**\n * Returns true if the path matches the handler's compiled url, method\n * and environment (e.g. client/server). If no options.method or options.where\n * is provided, then only the path will be used to test.\n */\nHandler.prototype.test = function (path, options) {\n  options = options || {};\n\n  var isUrlMatch = this.compiledUrl.test(path);\n  var isMethodMatch = true;\n  var isEnvMatch = true;\n\n  if (this.method && options.method)\n    isMethodMatch = this.method == options.method.toLowerCase();\n\n  if (options.where)\n    isEnvMatch = this.where == options.where;\n\n  return isUrlMatch && isMethodMatch && isEnvMatch;\n};\n\nHandler.prototype.params = function (path) {\n  return this.compiledUrl.params(path);\n};\n\nHandler.prototype.resolve = function (params, options) {\n  return this.compiledUrl.resolve(params, options);\n};\n\n/**\n * Returns a new cloned Handler.\n * XXX problem is here because we're not storing the original path.\n */\nHandler.prototype.clone = function () {\n  var clone = new Handler(this.path, this.handle, this.options);\n  // in case the original function had a name\n  clone.name = this.name;\n  return clone;\n};\n","var Url = Iron.Url;\nvar assert = Iron.utils.assert;\nvar defaultValue = Iron.utils.defaultValue;\n\n/**\n * Connect inspired middleware stack that works on the client and the server.\n *\n * You can add handlers to the stack for various paths. Those handlers can run\n * on the client or server. Then you can dispatch into the stack with a\n * given path by calling the dispatch method. This goes down the stack looking\n * for matching handlers given the url and environment (client/server). If we're\n * on the client and we should make a trip to the server, the onServerDispatch\n * callback is called.\n *\n * The middleware stack supports the Connect API. But it also allows you to\n * specify a context so we can have one context object (like a Controller) that\n * is a consistent context for each handler function called on a dispatch.\n *\n */\nMiddlewareStack = function () {\n  this._stack = [];\n  this.length = 0;\n};\n\nMiddlewareStack.prototype._create = function (path, fn, options) {\n  var handler = new Handler(path, fn, options);\n  var name = handler.name;\n\n  if (name) {\n    if (_.has(this._stack, name)) {\n      throw new Error(\"Handler with name '\" + name + \"' already exists.\");\n    }\n    this._stack[name] = handler;\n  }\n\n  return handler;\n};\n\nMiddlewareStack.prototype.findByName = function (name) {\n  return this._stack[name];\n};\n\n/**\n * Push a new handler onto the stack.\n */\nMiddlewareStack.prototype.push = function (path, fn, options) {\n  var handler = this._create(path, fn, options);\n  this._stack.push(handler);\n  this.length++;\n  return handler;\n};\n\nMiddlewareStack.prototype.append = function (/* fn1, fn2, [f3, f4]... */) {\n  var self = this;\n  var args = _.toArray(arguments);\n  var options = {};\n\n  if (typeof args[args.length-1] === 'object')\n    options = args.pop();\n\n  _.each(args, function (fnOrArray) {\n    if (typeof fnOrArray === 'undefined')\n      return;\n    else if (typeof fnOrArray === 'function')\n      self.push(fnOrArray, options);\n    else if (_.isArray(fnOrArray))\n      self.append.apply(self, fnOrArray.concat([options]));\n    else\n      throw new Error(\"Can only append functions or arrays to the MiddlewareStack\");\n  });\n\n  return this;\n};\n\n/**\n * Insert a handler at a specific index in the stack.\n *\n * The index behavior is the same as Array.prototype.splice. If the index is\n * greater than the stack length the handler will be appended at the end of the\n * stack. If the index is negative, the item will be inserted \"index\" elements\n * from the end.\n */\nMiddlewareStack.prototype.insertAt = function (index, path, fn, options) {\n  var handler = this._create(path, fn, options);\n  this._stack.splice(index, 0, handler);\n  this.length = this._stack.length;\n  return this;\n};\n\n/**\n * Insert a handler before another named handler.\n */\nMiddlewareStack.prototype.insertBefore = function (name, path, fn, options) {\n  var beforeHandler;\n  var index;\n\n  if (!(beforeHandler = this._stack[name]))\n    throw new Error(\"Couldn't find a handler named '\" + name + \"' on the path stack\");\n\n  index = _.indexOf(this._stack, beforeHandler);\n  this.insertAt(index, path, fn, options);\n  return this;\n};\n\n/**\n * Insert a handler after another named handler.\n *\n */\nMiddlewareStack.prototype.insertAfter = function (name, path, fn, options) {\n  var handler;\n  var index;\n\n  if (!(handler = this._stack[name]))\n    throw new Error(\"Couldn't find a handler named '\" + name + \"' on the path stack\");\n\n  index = _.indexOf(this._stack, handler);\n  this.insertAt(index + 1, path, fn, options);\n  return this;\n};\n\n/**\n * Return a new MiddlewareStack comprised of this stack joined with other\n * stacks. Note the new stack will not have named handlers anymore. Only the\n * handlers are cloned but not the name=>handler mapping.\n */\nMiddlewareStack.prototype.concat = function (/* stack1, stack2, */) {\n  var ret = new MiddlewareStack;\n  var concat = Array.prototype.concat;\n  var clonedThisStack = EJSON.clone(this._stack);\n  var clonedOtherStacks = _.map(_.toArray(arguments), function (s) { return EJSON.clone(s._stack); });\n  ret._stack = concat.apply(clonedThisStack, clonedOtherStacks);\n  this.length = ret._stack.length;\n  return ret;\n};\n\n/**\n * Dispatch into the middleware stack, allowing the handlers to control the\n * iteration by calling this.next();\n */\nMiddlewareStack.prototype.dispatch = function dispatch (url, context, done) {\n  var self = this;\n  var originalUrl = url;\n\n  assert(typeof url === 'string', \"Requires url\");\n  assert(typeof context === 'object', \"Requires context object\");\n\n  url = Url.normalize(url || '/');\n\n  defaultValue(context, 'request', {});\n  defaultValue(context, 'response', {});\n  defaultValue(context, 'originalUrl', url);\n\n  //defaultValue(context, 'location', Url.parse(originalUrl));\n  defaultValue(context, '_method', context.method);\n  defaultValue(context, '_handlersForEnv', {client: false, server: false});\n  defaultValue(context, '_handled', false);\n\n  defaultValue(context, 'isHandled', function () {\n    return context._handled;\n  });\n\n  defaultValue(context, 'willBeHandledOnClient', function () {\n    return context._handlersForEnv.client;\n  });\n\n  defaultValue(context, 'willBeHandledOnServer', function () {\n    return context._handlersForEnv.server;\n  });\n\n  var wrappedDone = function () {\n    if (done) {\n      try {\n        done.apply(this, arguments);\n      } catch (err) {\n        // if we catch an error at this point in the stack we don't want it\n        // handled in the next() iterator below. So we'll mark the error to tell\n        // the next iterator to ignore it.\n        err._punt = true;\n\n        // now rethrow it!\n        throw err;\n      }\n    }\n  };\n\n  var index = 0;\n\n  var next = Meteor.bindEnvironment(function boundNext (err) {\n    var handler = self._stack[index++];\n\n    // reset the url\n    context.url = context.request.url = context.originalUrl;\n\n    if (!handler)\n      return wrappedDone.call(context, err);\n\n    if (!handler.test(url, {method: context._method}))\n      return next(err);\n\n    // okay if we've gotten this far the handler matches our url but we still\n    // don't know if this is a client or server handler. Let's track that.\n    // XXX couldn't the environment be something else like cordova?\n    var where = Meteor.isClient ? 'client' : 'server';\n\n    // track that we have a handler for the given environment so long as it's\n    // not middleware created like this Router.use(function () {}). We'll assume\n    // that if the handler is of that form we don't want to make a trip to\n    // the client or the server for it.\n    if (!handler.middleware)\n      context._handlersForEnv[handler.where] = true;\n\n    // but if we're not actually on that env, skip to the next handler.\n    if (handler.where !== where)\n      return next(err);\n\n    // get the parameters for this url from the handler's compiled path\n    // XXX removing for now\n    //var params = handler.params(context.location.href);\n    //context.request.params = defaultValue(context, 'params', {});\n    //_.extend(context.params, params);\n\n    // so we can call this.next()\n    // XXX this breaks with things like request.body which require that the\n    // iterator be saved for the given function call.\n    context.next = next;\n\n    if (handler.mount) {\n      var mountpath = Url.normalize(handler.compiledUrl.pathname);\n      var newUrl = url.substr(mountpath.length, url.length);\n      newUrl = Url.normalize(newUrl);\n      context.url = context.request.url = newUrl;\n    }\n\n    try {\n      //\n      // The connect api says a handler signature (arity) can look like any of:\n      //\n      // 1) function (req, res, next)\n      // 2) function (err, req, res, next)\n      // 3) function (err)\n      var arity = handler.handle.length\n      var req = context.request;\n      var res = context.response;\n\n      // function (err, req, res, next)\n      if (err && arity === 4)\n        return handler.handle.call(context, err, req, res, next);\n\n      // function (req, res, next)\n      if (!err && arity < 4)\n        return handler.handle.call(context, req, res, next);\n\n      // default is function (err) so punt the error down the stack\n      // until we either find a handler who likes to deal with errors or we call\n      // out\n      return next(err);\n    } catch (err) {\n      if (err._punt)\n        // ignore this error and throw it down the stack\n        throw err;\n      else\n        // see if the next handler wants to deal with the error\n        next(err);\n    } finally {\n      // we'll put this at the end because some middleware\n      // might want to decide what to do based on whether we've\n      // been handled \"yet\". If we set this to true before the handler\n      // is called, there's no way for the handler to say, if we haven't been\n      // handled yet go to the server, for example.\n      context._handled = true;\n      context.next = null;\n    }\n  });\n\n  next();\n\n  context.next = null;\n  return context;\n};\n\nIron = Iron || {};\nIron.MiddlewareStack = MiddlewareStack;\n"]}